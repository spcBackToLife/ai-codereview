# 代码审查规则汇总

本文档整理了所有代码审查规则，按照规则类别和严重程度分类展示。

## 目录

- [TypeScript 代码审查规范](#typescript-代码审查规范)
- [React 代码审查规范](#react-代码审查规范)
- [代码设计审查规范](#代码设计审查规范)

---

## TypeScript 代码审查规范

### 强卡控级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| ts-001 | 类型定义规范 | 所有函数参数、返回值、变量必须显式声明类型，禁止使用 any，特殊情况使用 unknown | 类型定义可以提高代码可读性和可维护性，减少运行时错误 |
| ts-005 | 类型断言规范 | 优先使用类型守卫，谨慎使用类型断言，禁止使用 as any | 类型断言会绕过类型检查，容易引入运行时错误 |
| ts-009 | 空值处理 | 明确处理 null 和 undefined，使用可选链和空值合并运算符 | 明确处理空值可以避免运行时错误 |
| ts-011 | 禁止使用 @ts-ignore | 禁止使用 @ts-ignore 和 @ts-nocheck，应修复类型错误或使用 @ts-expect-error 并说明原因 | @ts-ignore 会忽略所有错误，@ts-expect-error 只在有错误时生效，更安全 |
| ts-015 | 类型兼容性 | 避免使用类型断言绕过类型检查，优先修复类型定义 | 类型断言会绕过类型检查，应该通过正确的类型定义来保证类型安全 |

### 建议级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| ts-002 | 接口和类型定义 | 优先使用 interface 定义对象类型，使用 type 定义联合类型、交叉类型等复杂类型 | interface 支持声明合并，适合扩展；type 适合复杂类型组合 |
| ts-003 | 可选属性使用 | 使用 ? 标记可选属性，使用 \| undefined 明确表示可能为 undefined | 明确区分可选属性和必填属性，提高类型安全性 |
| ts-004 | 泛型使用规范 | 合理使用泛型，避免过度使用，泛型参数使用有意义的名称 | 泛型可以提高代码复用性，但过度使用会增加复杂度 |
| ts-006 | 枚举使用规范 | 使用 const enum 或普通 enum，避免使用字符串字面量联合类型替代枚举 | 枚举提供更好的类型提示和重构支持 |
| ts-008 | 工具类型使用 | 合理使用 TypeScript 内置工具类型（Partial、Pick、Omit、Record 等） | 工具类型可以减少重复代码，提高类型定义的灵活性 |
| ts-012 | 类型导出规范 | 导出类型时使用 export type，避免类型和值混用 | 明确区分类型导出和值导出，提高代码清晰度 |
| ts-013 | readonly 使用 | 对于不应被修改的对象和数组，使用 readonly 修饰符 | readonly 可以在编译时防止意外修改，提高代码安全性 |
| ts-014 | 函数类型定义 | 使用函数类型别名或接口定义函数类型，避免重复定义 | 统一的函数类型定义可以提高代码复用性和一致性 |

### 优化级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| ts-007 | 函数重载规范 | 使用函数重载提供更精确的类型定义，避免使用联合类型参数 | 函数重载可以提供更精确的类型推断 |
| ts-010 | 类型导入规范 | 使用 import type 导入类型，避免类型导入影响运行时 | 类型导入在编译后会被移除，不影响打包体积 |

---

## React 代码审查规范

### 强卡控级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| react-001 | 组件命名规范 | 组件名必须使用 PascalCase，文件名与组件名保持一致 | 统一的命名规范提高代码可读性和可维护性 |
| react-002 | 函数组件优先 | 优先使用函数组件和 Hooks，避免使用类组件（除非有特殊需求） | 函数组件更简洁，Hooks 提供更好的逻辑复用 |
| react-003 | Props 类型定义 | 所有组件的 Props 必须使用 interface 或 type 定义类型 | 类型定义提供类型检查和 IDE 提示，减少错误 |
| react-004 | key 属性使用 | 列表渲染必须提供唯一且稳定的 key，禁止使用数组索引作为 key（除非列表不可变） | 正确的 key 帮助 React 识别列表项变化，提高渲染性能 |
| react-006 | useEffect 依赖项 | useEffect 必须正确声明依赖项，避免遗漏依赖导致闭包问题 | 正确的依赖项确保 effect 在正确的时机执行，避免闭包陷阱 |
| react-014 | 避免使用索引作为 key | 列表渲染时，如果列表项可能重新排序、添加或删除，禁止使用索引作为 key | 使用索引作为 key 会导致组件状态混乱和性能问题 |
| react-016 | 避免直接修改 state | 禁止直接修改 state，必须使用 setState 或状态更新函数 | 直接修改 state 不会触发重新渲染，可能导致 UI 不同步 |

### 建议级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| react-005 | useState 初始化 | useState 初始值应该明确类型，复杂对象使用函数式初始化 | 明确类型和函数式初始化可以避免不必要的计算和类型错误 |
| react-007 | useCallback 和 useMemo 使用 | 合理使用 useCallback 和 useMemo，避免过度优化，仅在必要时使用 | 过度使用 useCallback 和 useMemo 会增加代码复杂度，应仅在性能需要时使用 |
| react-008 | 条件渲染规范 | 使用逻辑与、三元运算符或提前返回进行条件渲染，保持 JSX 简洁 | 简洁的条件渲染提高代码可读性 |
| react-009 | 事件处理函数命名 | 事件处理函数使用 handle 或 on 前缀，保持命名一致性 | 统一的命名规范提高代码可读性 |
| react-010 | 避免在 render 中创建函数 | 避免在 JSX 中直接创建函数，应使用 useCallback 或提取到组件外部 | 避免每次渲染创建新函数，减少不必要的重渲染 |
| react-011 | 组件拆分原则 | 单个组件不应超过 300 行，复杂组件应拆分为多个小组件 | 拆分组件提高可维护性和可测试性 |
| react-012 | 自定义 Hooks 规范 | 提取可复用的逻辑到自定义 Hooks，Hook 名以 use 开头 | 自定义 Hooks 提高逻辑复用性，减少代码重复 |
| react-013 | Props 解构规范 | 在函数参数中解构 Props，使用默认值处理可选属性 | 解构 Props 使代码更简洁，默认值处理更清晰 |
| react-015 | 错误边界使用 | 在关键组件树周围使用 ErrorBoundary 捕获和处理错误 | 错误边界可以防止单个组件错误导致整个应用崩溃 |
| react-017 | Context 使用规范 | 合理使用 Context，避免过度使用导致性能问题，考虑将 Context 拆分 | 拆分 Context 可以减少不必要的重渲染，提高性能 |
| react-018 | 避免在 JSX 中使用复杂逻辑 | 将复杂逻辑提取到函数或 useMemo 中，保持 JSX 简洁 | 提取复杂逻辑提高代码可读性和可维护性 |
| react-019 | 组件导出规范 | 优先使用命名导出，默认导出仅用于页面组件或主要组件 | 统一的导出规范提高代码一致性和可维护性 |

### 优化级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| react-020 | 性能优化检查 | 对于大型列表或复杂组件，考虑使用 React.memo、useMemo、useCallback 进行优化 | 合理的性能优化可以减少不必要的重渲染，提高应用性能 |

---

## 代码设计审查规范

### 强卡控级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| design-001 | 单一职责原则 | 每个函数、类、模块应该只负责一个功能，避免功能耦合 | 单一职责原则提高代码可测试性、可维护性和可复用性 |
| design-003 | 避免深层嵌套 | 避免超过 3 层嵌套，使用提前返回、卫语句减少嵌套 | 减少嵌套提高代码可读性，提前返回使逻辑更清晰 |
| design-004 | 魔法数字和字符串 | 禁止使用魔法数字和字符串，应定义为常量或枚举 | 使用常量提高代码可读性和可维护性，便于统一修改 |
| design-005 | 错误处理规范 | 必须处理可能的错误，使用 try-catch 或返回 Result 类型，避免静默失败 | 错误处理确保应用稳定性和可调试性 |
| design-007 | 命名规范 | 使用有意义的变量和函数名，避免缩写（除非是通用缩写），使用动词命名函数 | 有意义的命名提高代码可读性，减少理解成本 |
| design-013 | 数据验证 | 在函数入口处验证输入参数，使用类型守卫或验证库 | 输入验证防止无效数据进入系统，提高系统稳定性 |
| design-014 | 避免全局变量 | 避免使用全局变量，使用模块导出或依赖注入 | 全局变量导致代码耦合，难以测试和维护 |
| design-017 | 配置外部化 | 将配置信息（API 地址、超时时间等）外部化，避免硬编码 | 配置外部化便于不同环境部署和统一管理 |
| design-021 | 文件长度限制 | 单个文件最大长度不应超过 400 行，超过时应拆分为多个文件 | 限制文件长度提高代码可读性、可维护性和可导航性，便于团队协作 |

### 建议级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| design-002 | 函数长度限制 | 单个函数不应超过 50 行，复杂逻辑应拆分为多个小函数 | 短函数更容易理解、测试和维护 |
| design-006 | 代码复用 | 避免重复代码，提取公共逻辑为函数或工具类 | 代码复用减少重复，提高可维护性，便于统一修改 |
| design-008 | 函数参数数量 | 函数参数不应超过 3 个，超过时应使用对象参数 | 对象参数提高可读性，便于扩展，参数顺序无关 |
| design-009 | 注释规范 | 代码应该自解释，仅在必要时添加注释。注释应说明为什么，而不是做什么 | 好的代码应该自解释，注释应提供代码无法表达的信息 |
| design-010 | 副作用管理 | 纯函数优先，副作用（API 调用、DOM 操作等）应明确标识和隔离 | 纯函数更容易测试和推理，副作用应该明确标识 |
| design-011 | 依赖注入 | 避免硬编码依赖，使用依赖注入提高可测试性和灵活性 | 依赖注入提高代码的可测试性和灵活性 |
| design-012 | 异步处理规范 | 统一使用 async/await，避免混用 Promise.then 和 async/await | 统一的异步处理方式提高代码一致性和可读性 |
| design-015 | 代码组织 | 相关代码应该组织在一起，按功能模块划分文件结构 | 良好的代码组织提高可维护性和可发现性 |
| design-018 | 避免深层对象访问 | 避免深层对象属性访问，使用可选链或提供默认值 | 深层访问容易导致运行时错误，应该安全访问 |
| design-019 | 函数纯度 | 优先编写纯函数，纯函数更容易测试和推理 | 纯函数更容易测试、调试和推理，提高代码质量 |
| design-020 | 代码复杂度控制 | 控制代码复杂度，单个函数的圈复杂度不应超过 10 | 控制复杂度提高代码可读性和可维护性 |

### 优化级别

| ID | 规则名称 | 描述 | 原因 |
|---|---|---|---|
| design-016 | 避免过度抽象 | 避免过早优化和过度抽象，在需要时再提取公共逻辑 | 过度抽象增加复杂度，应该在真正需要时再抽象 |

---

## 规则统计

### 按类别统计

| 类别 | 强卡控 | 建议 | 优化 | 总计 |
|---|---|---|---|---|
| TypeScript | 5 | 8 | 2 | 15 |
| React | 7 | 12 | 1 | 20 |
| 代码设计 | 9 | 11 | 1 | 21 |
| **总计** | **21** | **31** | **4** | **56** |

### 按级别统计

- **强卡控（21 条）**：必须遵守的规则，违反会导致代码质量问题
- **建议（31 条）**：推荐遵守的规则，有助于提高代码质量
- **优化（4 条）**：可选的优化规则，在特定场景下使用

---

## 使用说明

1. **强卡控级别**：这些规则是必须遵守的，违反会导致代码审查不通过
2. **建议级别**：这些规则是推荐遵守的，有助于提高代码质量和可维护性
3. **优化级别**：这些规则是可选的，在性能或特定场景下可以考虑使用

## 规则详情

每个规则的详细说明、正确示例和错误示例，请参考对应的规则 JSON 文件：
- `src/review/rules/typescript.json`
- `src/review/rules/react.json`
- `src/review/rules/codeDesign.json`

